<?php

// Load dependencies
require 'vendor/autoload.php';
use Aws\S3\S3Client;

class ScheduleCloudBackups extends WireData implements Module, ConfigurableModule {
	public static function getModuleInfo() {
		return array(
			'title'		=> 'ScheduleCloudBackups',
			'summary'	=> 'Backs up your site to Amazon S3',
			'version'	=> 1,
			'author'	=> 'David Robertson',
			'href'		=> 'https://github.com/DavidJRobertson/ProcessWire-ScheduleCloudBackups',
			'singular'	=> true,
			'autoload'	=> true
		);
	}

	const RUN_BACKUP_PATH = 'runbackup';

	public function init() {
		// Run the backup if the correct URL is requested
		$shouldBackup = (strpos($_SERVER['REQUEST_URI'], self::RUN_BACKUP_PATH) !== FALSE) &&
						wire('input')->get->hash &&
						wire('input')->get->hash == $this->backupHash;

		if ($shouldBackup) {
			$this->runBackup();
			die();
		}
	}



	/* BACKUP CREATION */
	public function ___runBackup() {
		ignore_user_abort(true);
		set_time_limit(600);

		$ts = date('Ymd-His', time());
		$keepfrom = strtotime("- " . $this->backupRetention); // Turns things like "1 Week" into the timestamp version of "Now - 1 Week" to determine how old the oldest backup should be
		$keepfrom = date('Ymd-His', $keepfrom); // Converts the timestamp into the format used when naming backups

		$this->outputSetup();
		$this->outputMessage("Starting backup...\n");

		// Backup the site to a tarball
		$this->createTarball();

		// Upload the tarball to S3
		$this->uploadBackup($ts);

		// Clean up after ourselves
		$this->deleteTarball();
		//$sitedir = wire('config')->paths->ScheduleCloudBackups . "tmp/";
		//$this->tidyBackups($sitedir, $keepfrom, '.tar.gz');

		$this->outputMessage("Backup complete.\n");
	}

	public function uploadBackup($ts) {
		$this->outputMessage("Uploading tarball to S3...  ");

		$config  = wire('config');
		$name = "$ts.tar.gz";
		$tarpath = $config->paths->ScheduleCloudBackups . "tmp/site_backup.tar.gz";

		$s3 = S3Client::factory(array(
			'key'    => $this->s3accesskey,
			'secret' => $this->s3secretkey
		));

		$result = $s3->putObject(array(
			'Bucket'     => $this->s3bucket,
			'Key'	     => $name, // TODO: fix this
			'SourceFile' => $tarpath
		));

		$this->outputMessage("Done.\n");
	}

	/* TARBALL */
	private function createTarball() {
		$config  = wire('config');

		$root    = $config->paths->root;
		$tarpath = $config->paths->ScheduleCloudBackups . "tmp/site_backup.tar.gz";

		$cmd = "cd $root && tar -czf $tarpath --exclude site/modules/ScheduleCloudBackups/tmp --exclude site/assets/sessions *";

		$this->createDatabaseDump();

		$this->outputMessage("Creating tarball...  ");
		system($cmd, $ec);
		$this->outputMessage("Done.\n");

		$this->deleteDatabaseDump();

		if ($ec != 0) {
			throw new WireException('Failed to create backup tarball.');
		}
	}
	private function deleteTarball() {
		$config	= wire('config');
		$file	= $config->paths->ScheduleCloudBackups . "tmp/site_backup.tar.gz";
		unlink($file);
		$this->outputMessage("Removed local copy of tarball.\n");
	}


	/* DATABASE DUMP */
	private function createDatabaseDump() {
		$this->outputMessage("Dumping database...  ");

		$config	= wire('config');

		$host	= $config->dbHost;
		$port	= $config->dbPort;
		$name	= $config->dbName;
		$user	= $config->dbUser;
		$pass	= $config->dbPass;
		$file	= $config->paths->root . 'data.sql';

		$cmd = "mysqldump --host=$host --port=$port --user=$user --password='$pass' $name > $file";
		system($cmd, $ec);
		if ($ec != 0) {
			throw new WireException('Failed to create database dump.');
		}
		$this->outputMessage("Done.\n");
	}
	private function deleteDatabaseDump() {
		$config	= wire('config');
		$file	= $config->paths->root . 'data.sql';
		unlink($file);
		$this->outputMessage("Removed local copy of database dump.\n");
	}

	/* CLEANUP */
	public function tidyBackups($path, $keepfrom) {
		// TODO: make this work with S3

		$filelist = scandir($path);

		foreach ($filelist as $backupfile) {
			if (stristr($backupfile, '.tar.gz')) {
				$filedate = explode('.tar.gz', $backupfile);
				if ($filedate[0] < $keepfrom) {
					unlink($path . $backupfile);
				}
			}
		}
	}

	/* RUNTIME OUTPUT */
	// Disabled by default
	public $outputEnabled = false;
	private function outputSetup() {
		if ($this->outputEnabled) {
			header('Content-Type: text/plain');
			if (function_exists('apache_setenv')) {
				@apache_setenv('no-gzip', '1');
			}
			@ini_set('zlib.output_compression', 'Off');
			@ini_set('output_buffering ', '0');
			@ini_set('implicit_flush', '1');
			@ob_implicit_flush(true);
			@ob_end_flush();
		}
	}
	private function outputMessage($message) {
		if ($this->outputEnabled) {
			echo $message;
			@ob_flush();
		}
	}

	/* CONFIGURATION */
	static public function getDefaultData() {
		return array(
			'backupRetention'	=> '1 Week',
			'backupHash'		=> '', // This is set at installation time anyway, but included for completeness

			's3accesskey'		=> '',
			's3secretkey'		=> '',
			's3bucket'			=> ''
		);
	}
	public function __construct() { // XXX: Is this actually necessary?
		foreach(self::getDefaultData() as $key => $value) {
			$this->$key = $value;
		}
	}
	static public function getModuleConfigInputfields(array $data) {
		$data = array_merge(self::getDefaultData(), $data);
		$fields = new InputfieldWrapper();

		// Instructions
		$backupurl = wire("pages")->get("/")->httpUrl . self::RUN_BACKUP_PATH . "?hash=" . $data["backupHash"];
		$field = wire('modules')->get("InputfieldMarkup");
		$field->label = 'Instructions';
		$field->description = "
			<p>To take a backup, go to <a href=\"$backupurl\">$backupurl</a></p>

			<p>Set the following to run as a cron job if you would like to take backups automatically:</p>
			<code><pre>wget -o /dev/null $backupurl</pre></code>";
		$fields->add($field);

		// S3 Access key
		$field = wire('modules')->get("InputfieldText");
		$field->name  = 's3accesskey';
		$field->label = 'S3 Access Key';
		$field->attr('value', $data['s3accesskey']);
		$field->columnWidth = 33;
		$fields->add($field);
		// S3 Secret key
		$field = wire('modules')->get("InputfieldText");
		$field->name  = 's3secretkey';
		$field->label = 'S3 Secret Key';
		$field->attr('value', $data['s3secretkey']);
		$field->columnWidth = 33;
		$fields->add($field);
		// S3 Bucket
		$field = wire('modules')->get("InputfieldText");
		$field->name  = 's3bucket';
		$field->label = 'S3 Bucket';
		$field->attr('value', $data['s3bucket']);
		$field->columnWidth = 33;
		$fields->add($field);

		// Retention Period
		$field = wire('modules')->get("InputfieldSelect");
		$field->name        = 'backupRetention';
		$field->label       = 'Backup Retention Period';
		$field->description = 'The length of time to keep backups';
		$field->value       = $data['backupRetention'];
		// Storing the options as a string so we can use strtotime.
		// This is because 1 month and 1 year don't always contain the same number of days
		$field->addOption('3 days', '3 days');
		$field->addOption('1 Week', '1 Week');
		$field->addOption('2 Weeks', '2 Weeks');
		$field->addOption('1 Month', '1 Month');
		$field->addOption('3 Months', '3 Months');
		$field->addOption('6 Months', '6 Months');
		$field->addOption('1 Year', '1 Year');
		$fields->add($field);

		// Security Hash
		$field = wire('modules')->get("InputfieldHidden");
		$field->name        = 'backupHash';
		$field->label       = 'Backup Hash';
		$field->description = 'A unique hash used to run backups via a cron job';
		$field->attr('value', $data['backupHash']);
		$fields->add($field);

		return $fields;
	}

	/* MODULE INSTALLATION */
	public function ___install() {
		if (PHP_OS != "Linux") {
			throw new WireException('Only Linux-based operating systems are supported.');
		} else if (ini_get('safe_mode') || !function_exists('system')) {
			throw new WireException('Cannot run shell commands (PHP safe mode probably enabled).');
		}

		// We need to create a secure hash for the cron job
		$data = array(
			'backupHash' => sha1(wire('user')->name . rand() . time() . rand())
		);
		wire('modules')->saveModuleConfigData('ScheduleCloudBackups', $data);
	}
	public function ___uninstall() {
		// No uninstall actions necessary
	}
}
?>

<?php
/**
 * ScheduleCloudBackups for ProcessWire
 * @author David Robertson
 *
 * @link http://modules.processwire.com/modules/schedule-cloud-backups
 * @link https://github.com/DavidJRobertson/ProcessWire-ScheduleCloudBackups
 */

// Load dependencies
require 'vendor/autoload.php';
use Aws\S3\S3Client;

class ScheduleCloudBackups extends WireData implements Module, ConfigurableModule {
	public static function getModuleInfo() {
		return array(
			'title'		=> 'ScheduleCloudBackups',
			'summary'	=> 'Backs up your site to Amazon S3',
			'version'	=> 2,
			'author'	=> 'David Robertson',
			'href'		=> 'https://github.com/DavidJRobertson/ProcessWire-ScheduleCloudBackups',
			'singular'	=> true,
			'autoload'	=> true
		);
	}

	const RUN_BACKUP_PATH  = 'runbackup';
	const TIMESTAMP_FORMAT = 'Ymd-His';

	public function init() {
		$input = wire('input');

		// Run the backup if the correct URL is requested
		$shouldBackup = ($input->get->it    == self::RUN_BACKUP_PATH) &&
						($input->get->token == $this->token);
		if ($shouldBackup) {
			if ($input->get->showstatus) {
				$this->outputEnabled = true;
			}

			$this->runBackup();
			die();
		}
	}

	/* BACKUP CREATION */
	public function ___runBackup() {
		header('Cache-Control: no-cache');
		ignore_user_abort(true);
		set_time_limit(600);
		$this->outputSetup();

		$this->outputMessage("Starting backup...\n");

		$this->createTarball();
		$this->uploadBackup($ts);
		$this->deleteTarball();
		$this->deleteOldBackups();

		$this->outputMessage("Backup complete.\n");
	}



	/* DATABASE DUMP */
	private function createDatabaseDump() {
		$config	= wire('config');
		$file	= $config->paths->root . 'data.sql';

		if (self::canMysqldump()) {
			$this->outputMessage("Dumping database [mysqldump]...  ");

			$host	= $config->dbHost;
			$port	= $config->dbPort;
			$name	= $config->dbName;
			$user	= $config->dbUser;
			$pass	= $config->dbPass;
			$cmd = "mysqldump --host=$host --port=$port --user=$user --password='$pass' $name > $file";
			system($cmd, $ec);
			if ($ec != 0) {
				throw new WireException('Failed to create database dump.');
			}
		} else {
			$this->outputMessage("Dumping database [php]... ");

			$handle = fopen($file, 'w+');
			fwrite($handle, $this->phpMysqldump());
			fclose($handle);
		}
		$this->outputMessage("Done.\n");
	}
	private function deleteDatabaseDump() {
		$config	= wire('config');
		$file	= $config->paths->root . 'data.sql';
		unlink($file);

		$this->outputMessage("Removed local copy of database dump.\n");
	}

	// Adapted from the wonderful blog of David Walsh to work with ProcessWire (makes it easier that we're already connected to the DB!)
	// Source: http://davidwalsh.name/backup-mysql-database-php
	private function phpMysqldump()	{
		$db = wire('db');

		$tables = array();
		$result = $db->query('SHOW TABLES');
		while ($row = mysqli_fetch_row($result)) {
			$tables[] = $row[0];
		}

		$sql = "-- Generated by ScheduleCloudBackups\n\n\n";

		foreach($tables as $table) {
			$sql .= "-- Table: $table\n";
			$sql .= "DROP TABLE IF EXISTS `$table`;\n";

			$row  = mysqli_fetch_row($db->query("SHOW CREATE TABLE `$table`"));
			$sql .= "$row[1];\n";

			$result = $db->query("SELECT * FROM `$table`");
			$num_fields = mysqli_num_fields($result);

			while($row = mysqli_fetch_row($result)) {
				$sql .= "INSERT INTO `$table` VALUES (";

				for ($f = 0; $f < $num_fields; $f++) {
					$data = $row[$f];
					$data = addslashes($data);
					$data = ereg_replace("\n", "\\n", $data);

					if (isset($data)) {
						if (is_numeric($data)) {
							$sql .= $data;
						} else {
							$sql .= "\"$data\"";
						}
					} else {
						$sql .= '""';
					}

					if ($f < ($num_fields - 1)) {
						$sql .= ', ';
					}
				}

				$sql .= ");\n";
			}

			$sql .="\n\n";
		}
		return $sql;
	}



	/* TARBALL */
	private function createTarball() {
		$this->createDatabaseDump();

		$config  = wire('config');
		$root    = $config->paths->root;

		if (self::canTar()) {
			$this->outputMessage("Creating tarball [tar]...  ");

			$tarpath = $config->paths->ScheduleCloudBackups . "tmp/site_backup.tar.gz";
			$dotfiles = "";
			foreach (glob("$root.?*") as $f) {
				$n = basename($f);
				if ($n != '..') {
					$dotfiles .= "$n ";
				}
			}
			$cmd = "(cd $root && tar -czf $tarpath --exclude='site/modules/ScheduleCloudBackups/tmp/site_backup.tar.gz' --exclude='site/assets/sessions/sess*' * $dotfiles)";
			system($cmd, $ec);

			if ($ec != 0) {
				$this->deleteDatabaseDump();
				throw new WireException('Failed to create backup tarball.');
			}
		} else {
			$this->outputMessage("Creating tarball [php]...  ");

			$tarpath = $config->paths->ScheduleCloudBackups . "tmp/site_backup.tar";
			unlink($tarpath);
			unlink("$tarpath.gz");
			$archive = new PharData($tarpath);
			$archive->buildFromDirectory($root);
			$archive->compress(Phar::GZ);
			unlink($tarpath);
		}
		$this->outputMessage("Done.\n");

		$this->deleteDatabaseDump();
	}
	private function deleteTarball() {
		$config	= wire('config');
		$file	= $config->paths->ScheduleCloudBackups . "tmp/site_backup.tar.gz";
		unlink($file);

		$this->outputMessage("Removed local copy of tarball.\n");
	}


	/* AWS S3 UPLOAD */
	public function uploadBackup() {
		$this->outputMessage("Uploading tarball to S3...  ");

		$s3 = S3Client::factory(array(
			'key'    => $this->s3accesskey,
			'secret' => $this->s3secretkey
		));

		$config  = wire('config');
		$result = $s3->putObject(array(
			'Bucket'     => $this->s3bucket,
			'Key'	     => date(self::TIMESTAMP_FORMAT) . '.tar.gz',
			'SourceFile' => $config->paths->ScheduleCloudBackups . 'tmp/site_backup.tar.gz'
		));

		$this->outputMessage("Done.\n");
	}

	/* CLEANUP */
	public function deleteOldBackups() {
		if ($this->retaindays < 1 && $this->retaincount < 1) return; // Cleanup disabled.
		$this->outputMessage("Cleaning up old backups...  ");

		$s3 = S3Client::factory(array(
			'key'    => $this->s3accesskey,
			'secret' => $this->s3secretkey
		));

		$toDelete = array();
		$n = 0;
		$objects = array_reverse($s3->getIterator('ListObjects', array(
			'Bucket' => $this->s3bucket
		))->toArray());
		foreach ($objects as $object) {
			$n++;
			$key   = $object['Key'];
			$tsstr = basename($key, '.tar.gz');
			$ts    = date_create_from_format(self::TIMESTAMP_FORMAT, $tsstr);
			$diff  = date_diff($ts, new DateTime(), true);
			$shouldDelete = ($this->retaindays  > 0 && $diff->d > $this->retaindays) ||
							($this->retaincount > 0 && $n       > $this->retaincount);
			if ($shouldDelete) {
				$this->outputMessage("\nDeleting $key");
				$toDelete[] = array('Key' => $key);
			}
		}

		if (count($toDelete)) {
			$this->outputMessage("\n");
			$s3->deleteObjects(array(
				'Bucket'  => $this->s3bucket,
				'Objects' => $toDelete
			));
		}

		$this->outputMessage("Done.\n");
	}

	/* CAPABILITIES */
	private static function canSystem() {
		return !ini_get('safe_mode') && function_exists('system');
	}
	private static function canMysqldump() {
		return self::canSystem() && `which mysqldump`;
	}
	private static function canTar() {
		return self::canSystem() && `which tar`;
	}


	/* RUNTIME OUTPUT */
	public $outputEnabled = false;
	private function outputSetup() {
		if ($this->outputEnabled) {
			header('Content-Type: text/plain');
			if (function_exists('apache_setenv')) {
				@apache_setenv('no-gzip', '1');
			}
			@ini_set('zlib.output_compression', 'Off');
			@ini_set('output_buffering ', '0');
			@ini_set('implicit_flush', '1');
			@ob_implicit_flush(true);
			@ob_end_flush();
		}
	}
	private function outputMessage($message) {
		if ($this->outputEnabled) {
			echo $message;
			@ob_flush();
		}
	}

	/* CONFIGURATION */
	static public function getDefaultData() {
		return array(
			'retaindays'	=> 0,
			'retaincount'	=> 5,
			'token'			=> '',
			's3accesskey'	=> '',
			's3secretkey'	=> '',
			's3bucket'		=> ''
		);
	}
	public function __construct() { // XXX: Is this actually necessary?
		foreach(self::getDefaultData() as $key => $value) {
			$this->$key = $value;
		}
	}
	static public function getModuleConfigInputfields(array $data) {
		$data = array_merge(self::getDefaultData(), $data);
		$fields = new InputfieldWrapper();

		// Instructions
		$backupurl = wire("pages")->get("/")->httpUrl . self::RUN_BACKUP_PATH . "?token=" . $data["token"];
		$field = wire('modules')->get("InputfieldMarkup");
		$field->label = 'Instructions';
		$field->description = "
			<p>To take a backup, go to <a href=\"$backupurl\">$backupurl</a></p>

			<p>Set the following to run as a cron job if you would like to take backups automatically:</p>
			<code><pre>wget -qO /dev/null $backupurl</pre></code>";
		$fields->add($field);

		// Status
		$field = wire('modules')->get("InputfieldMarkup");
		$field->label = 'Backup Status';
		$field->description = self::getStatus($data);
		$fields->add($field);

		// S3 Access key
		$field = wire('modules')->get("InputfieldText");
		$field->name  = 's3accesskey';
		$field->label = 'S3 Access Key ID';
		$field->attr('value', $data['s3accesskey']);
		$field->columnWidth = 33;
		$fields->add($field);
		// S3 Secret key
		$field = wire('modules')->get("InputfieldText");
		$field->name  = 's3secretkey';
		$field->label = 'S3 Secret Access Key';
		$field->attr('value', $data['s3secretkey']);
		$field->columnWidth = 33;
		$fields->add($field);
		// S3 Bucket
		$field = wire('modules')->get("InputfieldText");
		$field->name  = 's3bucket';
		$field->label = 'S3 Bucket Name';
		$field->attr('value', $data['s3bucket']);
		$field->columnWidth = 34;
		$fields->add($field);

		// Retention Period
		$field = wire('modules')->get("InputfieldInteger");
		$field->name        = 'retaindays';
		$field->label       = 'Backup Retention Period (days)';
		$field->description = 'The number of days to keep backups. Set to 0 to disable.';
		$field->value       = $data['retaindays'];
		$field->min         = 0;
		$field->inputType	= 'number';
		$field->columnWidth = 50;
		$fields->add($field);

		// Backup Count
		$field = wire('modules')->get("InputfieldInteger");
		$field->name        = 'retaincount';
		$field->label       = 'Backup Count';
		$field->description = 'The maximum number of backups to keep. Set to 0 to disable.';
		$field->value       = $data['retaincount'];
		$field->min         = 0;
		$field->inputType	= 'number';
		$field->columnWidth = 50;
		$fields->add($field);

		// Security Token
		$field = wire('modules')->get("InputfieldHidden");
		$field->name        = 'token';
		$field->label       = 'Security Token';
		$field->description = 'A unique token used to authenticate requests to run a backup';
		$field->attr('value', $data['token']);
		$fields->add($field);

		return $fields;
	}

	private static function getStatus($data) {
		if (!$data['s3accesskey'] || !$data['s3secretkey'] || !$data['s3bucket']) {
			return "
			<p>Please fill in your S3 details below.</p>

			<a target=\"_blank\" href=\"https://github.com/DavidJRobertson/ProcessWire-ScheduleCloudBackups/blob/master/readme.md#instructions-for-setting-up-s3\">Instructions for setting up S3</a>";
		}

		try {
			$out = "";
			$s3 = S3Client::factory(array(
				'key'    => $data['s3accesskey'],
				'secret' => $data['s3secretkey']
			));
			$objects = $s3->getIterator('ListObjects', array(
				'Bucket' => $data['s3bucket']
			))->toArray();

			if (count($objects)) {
				$out .= "<table>";
				$out .= "	<tr>";
				$out .= "		<th>Date</th>";
				$out .= "		<th>Size</th>";
				$out .= "		<th></th>";
				$out .= "	</tr>";

				foreach ($objects as $object) {
					$ts = date_create_from_format(self::TIMESTAMP_FORMAT, basename($object['Key'], '.tar.gz'));
					$date = $ts->format('Y-m-d H:i:s');

					$base = log($object['Size']) / log(1024);
				    $suffixes = array(' B', ' kB', ' MB', ' GB', ' TB', ' PB', ' EB', ' ZB', ' YB'); // Heh, yottabytes...
				    $size = round(pow(1024, $base - floor($base)), 2) . $suffixes[floor($base)];

					$link = $s3->getObjectUrl($data['s3bucket'], $object['Key'], '+1 week');

					$out .= "	<tr>";
					$out .= "		<td>$date &nbsp;</td>";
					$out .= "		<td>$size &nbsp;</td>";
					$out .= "		<td><a href=\"$link\">Download</a> &nbsp;</td>";
					$out .= "	</tr>";
				}
				$out .= "</table>";
			} else {
				$out .= "<p>No backups taken.</p>";
			}

			$out .= "<p>";
			if (self::canMysqldump()) {
				$out .= "Using native `mysqldump`. ";
			} else {
				$out .= "Using pure-PHP mysqldump. ";
			}
			if (self::canTar()) {
				$out .= "Using native `tar`. ";
			} else {
				$out .= "Using pure-PHP tar. ";
			}
			$out .= "</p>";
			return $out;
		} catch (Aws\S3\Exception\InvalidAccessKeyIdException $e) {
			return "<p class=\"WireException\">Invalid s3 access key id!</p>";
		} catch (Aws\S3\Exception\SignatureDoesNotMatchException $e) {
			return "<p>Invalid s3 secret key!</p>";
		} catch (Aws\S3\Exception\NoSuchBucketException $e) {
			return "<p>S3 bucket does not exist!</p>";
		} catch (Exception $e){
			return "<code>$e</code>";
		}
	}

	/* MODULE INSTALLATION */
	public function ___install() {
		// Create a security token
		wire('modules')->saveModuleConfigData('ScheduleCloudBackups', array(
			'token' => sha1(wire('user')->name . rand() . time() . rand())
		));
	}
	public function ___uninstall() {
		// No uninstall actions necessary
	}
}
?>
